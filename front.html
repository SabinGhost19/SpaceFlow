<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plan 3D - Vizualizare Camere »ôi Pere»õi</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 100;
            max-width: 350px;
            backdrop-filter: blur(10px);
        }

        #info h1 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        #info p {
            margin: 8px 0;
            color: #555;
            font-size: 14px;
            line-height: 1.6;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .controls button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .controls button:active {
            transform: translateY(0);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
        }

        .slider-container label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            min-width: 120px;
        }

        .slider-container input[type="range"] {
            flex: 1;
            min-width: 150px;
        }

        .slider-container span {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 200;
            text-align: center;
        }

        #loading h2 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <div id="loading">
        <h2>Se √ÆncarcƒÉ planul 3D...</h2>
        <div class="spinner"></div>
    </div>

    <div id="info">
        <h1>üè¢ Vizualizare Plan 3D</h1>
        <p><strong>Controale:</strong></p>
        <p>üñ±Ô∏è Click st√¢nga + drag: Rotire camerƒÉ</p>
        <p>üñ±Ô∏è Click dreapta + drag: Panoramare</p>
        <p>üéØ Scroll: Zoom</p>
        <p><strong>Camere detectate:</strong> <span id="roomCount">0</span></p>
        <p><strong>Pere»õi detecta»õi:</strong> <span id="wallCount">0</span></p>
    </div>

    <div class="controls">
        <button id="resetView">üîÑ Resetare Vedere</button>
        <button id="toggleWalls">üß± Toggle Pere»õi</button>
        <button id="toggleRooms">üè† Toggle Camere</button>
        <button id="toggleLabels">üè∑Ô∏è Toggle Etichete</button>
        <button id="toggle2D">üìê Vedere 2D/3D</button>

        <div class="slider-container">
            <label for="wallHeight">√énƒÉl»õime Pere»õi:</label>
            <input type="range" id="wallHeight" min="50" max="500" value="250" step="10">
            <span id="wallHeightValue">250</span>
        </div>

        <div class="slider-container">
            <label for="floorHeight">√énƒÉl»õime Podea:</label>
            <input type="range" id="floorHeight" min="-100" max="100" value="0" step="5">
            <span id="floorHeightValue">0</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Variabile globale
        let scene, camera, renderer, controls;
        let wallsGroup, roomsGroup, labelsGroup;
        let svgData = null;
        let wallHeight = 250;
        let floorHeight = 0;
        let showWalls = true;
        let showRooms = true;
        let showLabels = true;
        let is2DView = false;

        // Cache pentru materiale »ôi geometrii (optimizare)
        const materialCache = new Map();
        const geometryCache = new Map();

        // Performance counters
        let totalWalls = 0;
        let totalRooms = 0;

        // Bounds pentru centrare camera
        let planBounds = {
            minX: Infinity, maxX: -Infinity,
            minY: Infinity, maxY: -Infinity,
            minZ: Infinity, maxZ: -Infinity
        };

        // Ini»õializare scenƒÉ Three.js
        function initScene() {
            const container = document.getElementById('container');

            // ScenƒÉ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            scene.fog = new THREE.Fog(0xf0f0f0, 1000, 5000);

            // CamerƒÉ - pozi»õie mai zoom out
            camera = new THREE.PerspectiveCamera(
                75, // FOV mai mare pentru vedere mai largƒÉ
                window.innerWidth / window.innerHeight,
                1,
                15000
            );
            // Pozi»õia ini»õialƒÉ va fi setatƒÉ dupƒÉ √ÆncƒÉrcarea SVG pentru centrare perfectƒÉ
            camera.position.set(0, 2000, 0);
            camera.lookAt(0, 0, 0);

            // Renderer - optimizat
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance",
                precision: "mediump"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // LimiteazƒÉ DPR pentru performance
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = false; // Update manual doar c√¢nd e necesar
            container.appendChild(renderer.domElement);

            // Controale orbitƒÉ - optimizate pentru fluiditate
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08; // Mai fluid
            controls.screenSpacePanning = true;
            controls.minDistance = 200;
            controls.maxDistance = 8000;
            controls.maxPolarAngle = Math.PI / 2;
            controls.rotateSpeed = 0.8; // Rota»õie mai smoothƒÉ
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;

            // Grupuri pentru organizare
            wallsGroup = new THREE.Group();
            wallsGroup.name = 'Walls';
            scene.add(wallsGroup);

            roomsGroup = new THREE.Group();
            roomsGroup.name = 'Rooms';
            scene.add(roomsGroup);

            labelsGroup = new THREE.Group();
            labelsGroup.name = 'Labels';
            scene.add(labelsGroup);

            // Lumini
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1000, 1500, 1000);
            directionalLight1.castShadow = true;
            directionalLight1.shadow.mapSize.width = 2048;
            directionalLight1.shadow.mapSize.height = 2048;
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1000, 1000, -1000);
            scene.add(directionalLight2);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3);
            scene.add(hemisphereLight);

            // Grid ajutƒÉtor
            const gridHelper = new THREE.GridHelper(4000, 50, 0x888888, 0xcccccc);
            scene.add(gridHelper);

            // Axe ajutƒÉtoare
            const axesHelper = new THREE.AxesHelper(500);
            scene.add(axesHelper);

            // Event listeners
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        // √éncƒÉrcare »ôi parsare SVG
        async function loadSVG() {
            try {
                const response = await fetch('floor-plan.svg');
                const svgText = await response.text();
                const parser = new DOMParser();
                svgData = parser.parseFromString(svgText, 'image/svg+xml');

                parseSVGAndCreate3D();

                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Eroare la √ÆncƒÉrcarea SVG:', error);
                document.getElementById('loading').innerHTML = '<h2>Eroare la √ÆncƒÉrcare!</h2><p>' + error.message + '</p>';
            }
        }

        // Parsare SVG »ôi creare obiecte 3D
        function parseSVGAndCreate3D() {
            if (!svgData) return;

            // Extrage informa»õii din SVG
            const svg = svgData.querySelector('svg');
            const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
            const width = viewBox[2];
            const height = viewBox[3];

            // Centru SVG pentru centrare
            const centerX = width / 2;
            const centerY = height / 2;

            let wallCount = 0;
            let roomCount = 0;

            // Reset bounds
            planBounds = {
                minX: Infinity, maxX: -Infinity,
                minY: Infinity, maxY: -Infinity,
                minZ: Infinity, maxZ: -Infinity
            };

            // Extrage toate elementele SVG
            const lines = svgData.querySelectorAll('line');
            const paths = svgData.querySelectorAll('path');
            const rects = svgData.querySelectorAll('rect');
            const polygons = svgData.querySelectorAll('polygon');
            const polylines = svgData.querySelectorAll('polyline');
            const circles = svgData.querySelectorAll('circle');
            const ellipses = svgData.querySelectorAll('ellipse');

            // Procesare linii (pere»õi)
            lines.forEach(line => {
                const x1 = parseFloat(line.getAttribute('x1')) - centerX;
                const y1 = parseFloat(line.getAttribute('y1')) - centerY;
                const x2 = parseFloat(line.getAttribute('x2')) - centerX;
                const y2 = parseFloat(line.getAttribute('y2')) - centerY;

                const stroke = line.getAttribute('stroke');
                const strokeWidth = parseFloat(line.getAttribute('stroke-width')) || 1;

                // DeterminƒÉ dacƒÉ este perete (linii mai groase sau negre)
                if (strokeWidth > 0.5 || stroke === '#000000' || stroke === 'black') {
                    createWall(x1, -y1, x2, -y2, strokeWidth);
                    wallCount++;
                }
            });

            // Procesare dreptunghiuri (camere poten»õiale)
            rects.forEach(rect => {
                const x = parseFloat(rect.getAttribute('x')) - centerX;
                const y = parseFloat(rect.getAttribute('y')) - centerY;
                const w = parseFloat(rect.getAttribute('width'));
                const h = parseFloat(rect.getAttribute('height'));
                const fill = rect.getAttribute('fill');
                const stroke = rect.getAttribute('stroke');
                const strokeWidth = parseFloat(rect.getAttribute('stroke-width')) || 1;

                // CreeazƒÉ camerƒÉ dacƒÉ are fill »ôi nu este transparent
                if (fill && fill !== 'none' && w > 10 && h > 10) {
                    createRoom([
                        { x: x, y: -y },
                        { x: x + w, y: -y },
                        { x: x + w, y: -(y + h) },
                        { x: x, y: -(y + h) }
                    ], fill);
                    roomCount++;
                }

                // CreeazƒÉ pere»õi din contur dacƒÉ are stroke
                if (stroke && stroke !== 'none' && strokeWidth > 0.5) {
                    createWall(x, -y, x + w, -y, strokeWidth);
                    createWall(x + w, -y, x + w, -(y + h), strokeWidth);
                    createWall(x + w, -(y + h), x, -(y + h), strokeWidth);
                    createWall(x, -(y + h), x, -y, strokeWidth);
                    wallCount += 4;
                }
            });

            // Procesare cercuri
            circles.forEach(circle => {
                const cx = parseFloat(circle.getAttribute('cx')) - centerX;
                const cy = parseFloat(circle.getAttribute('cy')) - centerY;
                const r = parseFloat(circle.getAttribute('r'));
                const fill = circle.getAttribute('fill');
                const stroke = circle.getAttribute('stroke');

                if (r > 5) {
                    // CreeazƒÉ camerƒÉ circularƒÉ dacƒÉ are fill
                    if (fill && fill !== 'none') {
                        createCircularRoom(cx, -cy, r, fill);
                        roomCount++;
                    }

                    // CreeazƒÉ perete circular dacƒÉ are stroke
                    if (stroke && stroke !== 'none') {
                        createCircularWall(cx, -cy, r, parseFloat(circle.getAttribute('stroke-width')) || 2);
                        wallCount++;
                    }
                }
            });

            // Procesare elipse
            ellipses.forEach(ellipse => {
                const cx = parseFloat(ellipse.getAttribute('cx')) - centerX;
                const cy = parseFloat(ellipse.getAttribute('cy')) - centerY;
                const rx = parseFloat(ellipse.getAttribute('rx'));
                const ry = parseFloat(ellipse.getAttribute('ry'));
                const fill = ellipse.getAttribute('fill');
                const stroke = ellipse.getAttribute('stroke');

                if (rx > 5 && ry > 5) {
                    // CreeazƒÉ camerƒÉ elipticƒÉ dacƒÉ are fill
                    if (fill && fill !== 'none') {
                        createEllipticalRoom(cx, -cy, rx, ry, fill);
                        roomCount++;
                    }

                    // CreeazƒÉ perete eliptic dacƒÉ are stroke
                    if (stroke && stroke !== 'none') {
                        createEllipticalWall(cx, -cy, rx, ry, parseFloat(ellipse.getAttribute('stroke-width')) || 2);
                        wallCount++;
                    }
                }
            });

            // Procesare poligoane (camere cu forme complexe)
            polygons.forEach(polygon => {
                const points = polygon.getAttribute('points');
                const fill = polygon.getAttribute('fill');

                if (points && fill && fill !== 'none') {
                    const coords = parsePointsString(points, centerX, centerY);
                    if (coords.length >= 3) {
                        createRoom(coords, fill);
                        roomCount++;
                    }
                }
            });

            // Procesare polylines (pere»õi complexi)
            polylines.forEach(polyline => {
                const points = polyline.getAttribute('points');
                const stroke = polyline.getAttribute('stroke');
                const strokeWidth = parseFloat(polyline.getAttribute('stroke-width')) || 1;

                if (points && strokeWidth > 0.5) {
                    const coords = parsePointsString(points, centerX, centerY);
                    for (let i = 0; i < coords.length - 1; i++) {
                        createWall(coords[i].x, coords[i].y, coords[i + 1].x, coords[i + 1].y, strokeWidth);
                        wallCount++;
                    }
                }
            });

            // Procesare paths (pere»õi »ôi camere complexe)
            paths.forEach(path => {
                const d = path.getAttribute('d');
                const fill = path.getAttribute('fill');
                const stroke = path.getAttribute('stroke');
                const strokeWidth = parseFloat(path.getAttribute('stroke-width')) || 1;

                if (d) {
                    const coords = parsePathData(d, centerX, centerY);

                    // DacƒÉ are fill, creeazƒÉ camerƒÉ
                    if (fill && fill !== 'none' && coords.length >= 3) {
                        createRoom(coords, fill);
                        roomCount++;
                    }

                    // DacƒÉ are stroke gros, creeazƒÉ pere»õi
                    if (stroke && stroke !== 'none' && strokeWidth > 0.5) {
                        for (let i = 0; i < coords.length - 1; i++) {
                            createWall(coords[i].x, coords[i].y, coords[i + 1].x, coords[i + 1].y, strokeWidth);
                            wallCount++;
                        }
                    }
                }
            });

            // DacƒÉ nu s-au gƒÉsit pere»õi din linii, √ÆncearcƒÉ sƒÉ extragi din path-uri
            if (wallCount === 0) {
                // Extrage contururi din toate elementele
                const allElements = svgData.querySelectorAll('*');
                allElements.forEach(element => {
                    const tagName = element.tagName.toLowerCase();
                    if (['line', 'path', 'polyline', 'polygon'].includes(tagName)) {
                        const stroke = element.getAttribute('stroke');
                        const strokeWidth = parseFloat(element.getAttribute('stroke-width')) || 1;

                        // ProceseazƒÉ orice element cu stroke vizibil
                        if (stroke && stroke !== 'none') {
                            processElementForWalls(element, centerX, centerY, strokeWidth);
                            wallCount++;
                        }
                    }
                });
            }

            // ActualizeazƒÉ contoarele
            document.getElementById('roomCount').textContent = totalRooms;
            document.getElementById('wallCount').textContent = totalWalls;

            console.log(`‚úÖ Procesate: ${totalWalls} pere»õi, ${totalRooms} camere`);
            console.log(`üìä Geometrii √Æn cache: ${geometryCache.size}`);
            console.log(`üé® Materiale √Æn cache: ${materialCache.size}`);
            console.log(`üìê Plan bounds:`, planBounds);

            // CentreazƒÉ camera pe mijlocul planului
            centerCameraOnPlan();
        }

        // Parsare string de puncte
        function parsePointsString(pointsStr, centerX, centerY) {
            const coords = [];
            const points = pointsStr.trim().split(/[\s,]+/);

            for (let i = 0; i < points.length - 1; i += 2) {
                coords.push({
                    x: parseFloat(points[i]) - centerX,
                    y: -(parseFloat(points[i + 1]) - centerY)
                });
            }

            return coords;
        }

        // Parsare date path SVG - versiune robustƒÉ cu suport pentru curbe
        function parsePathData(d, centerX, centerY) {
            const coords = [];
            const commands = d.match(/[a-df-z][^a-df-z]*/gi);

            if (!commands) return coords;

            let currentX = 0, currentY = 0;
            let startX = 0, startY = 0;
            let lastControlX = 0, lastControlY = 0;

            commands.forEach(cmd => {
                const type = cmd[0];
                const args = cmd.slice(1).trim().split(/[\s,]+/).filter(x => x).map(Number);

                switch (type.toUpperCase()) {
                    case 'M': // Move to
                        currentX = type === 'M' ? args[0] : currentX + args[0];
                        currentY = type === 'M' ? args[1] : currentY + args[1];
                        startX = currentX;
                        startY = currentY;
                        coords.push({ x: currentX - centerX, y: -(currentY - centerY) });
                        break;

                    case 'L': // Line to
                        for (let i = 0; i < args.length; i += 2) {
                            currentX = type === 'L' ? args[i] : currentX + args[i];
                            currentY = type === 'L' ? args[i + 1] : currentY + args[i + 1];
                            coords.push({ x: currentX - centerX, y: -(currentY - centerY) });
                        }
                        break;

                    case 'H': // Horizontal line
                        currentX = type === 'H' ? args[0] : currentX + args[0];
                        coords.push({ x: currentX - centerX, y: -(currentY - centerY) });
                        break;

                    case 'V': // Vertical line
                        currentY = type === 'V' ? args[0] : currentY + args[0];
                        coords.push({ x: currentX - centerX, y: -(currentY - centerY) });
                        break;

                    case 'C': // Cubic Bezier curve
                        // AproximeazƒÉ curba cu linii pentru simplitate
                        const segments = 10;
                        const x0 = currentX, y0 = currentY;
                        const x1 = type === 'C' ? args[0] : currentX + args[0];
                        const y1 = type === 'C' ? args[1] : currentY + args[1];
                        const x2 = type === 'C' ? args[2] : currentX + args[2];
                        const y2 = type === 'C' ? args[3] : currentY + args[3];
                        const x3 = type === 'C' ? args[4] : currentX + args[4];
                        const y3 = type === 'C' ? args[5] : currentY + args[5];

                        for (let i = 1; i <= segments; i++) {
                            const t = i / segments;
                            const mt = 1 - t;
                            const bx = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                            const by = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
                            coords.push({ x: bx - centerX, y: -(by - centerY) });
                        }
                        currentX = x3;
                        currentY = y3;
                        lastControlX = x2;
                        lastControlY = y2;
                        break;

                    case 'Q': // Quadratic Bezier curve
                        const qSegments = 8;
                        const qx0 = currentX, qy0 = currentY;
                        const qx1 = type === 'Q' ? args[0] : currentX + args[0];
                        const qy1 = type === 'Q' ? args[1] : currentY + args[1];
                        const qx2 = type === 'Q' ? args[2] : currentX + args[2];
                        const qy2 = type === 'Q' ? args[3] : currentY + args[3];

                        for (let i = 1; i <= qSegments; i++) {
                            const t = i / qSegments;
                            const mt = 1 - t;
                            const qbx = mt * mt * qx0 + 2 * mt * t * qx1 + t * t * qx2;
                            const qby = mt * mt * qy0 + 2 * mt * t * qy1 + t * t * qy2;
                            coords.push({ x: qbx - centerX, y: -(qby - centerY) });
                        }
                        currentX = qx2;
                        currentY = qy2;
                        lastControlX = qx1;
                        lastControlY = qy1;
                        break;

                    case 'A': // Arc - aproximeazƒÉ cu linii
                        if (args.length >= 7) {
                            const aSegments = 12;
                            const endX = type === 'A' ? args[5] : currentX + args[5];
                            const endY = type === 'A' ? args[6] : currentY + args[6];

                            // Aproximare simplƒÉ - linie dreaptƒÉ pentru arc
                            for (let i = 1; i <= aSegments; i++) {
                                const t = i / aSegments;
                                const ax = currentX + (endX - currentX) * t;
                                const ay = currentY + (endY - currentY) * t;
                                coords.push({ x: ax - centerX, y: -(ay - centerY) });
                            }
                            currentX = endX;
                            currentY = endY;
                        }
                        break;

                    case 'Z': // Close path
                        if (Math.abs(currentX - startX) > 0.1 || Math.abs(currentY - startY) > 0.1) {
                            coords.push({ x: startX - centerX, y: -(startY - centerY) });
                        }
                        currentX = startX;
                        currentY = startY;
                        break;
                }
            });

            return coords;
        }        // Procesare element pentru pere»õi
        function processElementForWalls(element, centerX, centerY, strokeWidth) {
            const tagName = element.tagName.toLowerCase();

            if (tagName === 'line') {
                const x1 = parseFloat(element.getAttribute('x1')) - centerX;
                const y1 = -(parseFloat(element.getAttribute('y1')) - centerY);
                const x2 = parseFloat(element.getAttribute('x2')) - centerX;
                const y2 = -(parseFloat(element.getAttribute('y2')) - centerY);
                createWall(x1, y1, x2, y2, strokeWidth);
            } else if (tagName === 'path') {
                const d = element.getAttribute('d');
                if (d) {
                    const coords = parsePathData(d, centerX, centerY);
                    for (let i = 0; i < coords.length - 1; i++) {
                        createWall(coords[i].x, coords[i].y, coords[i + 1].x, coords[i + 1].y, strokeWidth);
                    }
                }
            }
        }

        // Actualizare bounds
        function updateBounds(x, y, z) {
            planBounds.minX = Math.min(planBounds.minX, x);
            planBounds.maxX = Math.max(planBounds.maxX, x);
            planBounds.minY = Math.min(planBounds.minY, y);
            planBounds.maxY = Math.max(planBounds.maxY, y);
            planBounds.minZ = Math.min(planBounds.minZ, z);
            planBounds.maxZ = Math.max(planBounds.maxZ, z);
        }

        // Creare perete 3D - optimizat cu cache
        function createWall(x1, y1, x2, y2, thickness = 5) {
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1);

            if (length < 1) return; // Skip pere»õi prea mici

            // Actualizare bounds
            updateBounds(x1, wallHeight / 2 + floorHeight, y1);
            updateBounds(x2, wallHeight / 2 + floorHeight, y2);

            // Rotunje»ôte dimensiunile pentru cache mai eficient
            const roundedLength = Math.round(length / 10) * 10;
            const roundedThickness = Math.max(Math.round(thickness), 3);
            const geometryKey = `wall_${roundedLength}_${wallHeight}_${roundedThickness}`;

            // Refolose»ôte geometria din cache
            if (!geometryCache.has(geometryKey)) {
                geometryCache.set(geometryKey,
                    new THREE.BoxGeometry(roundedLength, wallHeight, roundedThickness)
                );
            }
            const geometry = geometryCache.get(geometryKey);

            // Refolose»ôte materialul din cache
            if (!materialCache.has('wall')) {
                materialCache.set('wall', new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.8,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                }));
            }
            const material = materialCache.get('wall');

            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(
                (x1 + x2) / 2,
                wallHeight / 2 + floorHeight,
                (y1 + y2) / 2
            );
            wall.rotation.y = -angle;
            wall.castShadow = true;
            wall.receiveShadow = true;

            // Frustum culling
            wall.frustumCulled = true;

            wallsGroup.add(wall);
            totalWalls++;
        }        // Creare camerƒÉ (podea) 3D - optimizat
        function createRoom(points, fillColor) {
            if (points.length < 3) return;

            // Actualizare bounds
            points.forEach(p => updateBounds(p.x, floorHeight, p.y));

            // Creare shape din puncte
            const shape = new THREE.Shape();
            shape.moveTo(points[0].x, points[0].y);

            for (let i = 1; i < points.length; i++) {
                shape.lineTo(points[i].x, points[i].y);
            }
            shape.closePath();

            // Geometrie extrudatƒÉ pentru podea - optimizatƒÉ
            const extrudeSettings = {
                depth: 10,
                bevelEnabled: false,
                curveSegments: 1 // Reduce segments pentru performance
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            // Culoare din SVG sau aleatorie
            let color = 0xcccccc;
            if (fillColor && fillColor.startsWith('#')) {
                color = parseInt(fillColor.substring(1), 16);
            } else if (fillColor && fillColor.startsWith('rgb')) {
                // Parse RGB
                const matches = fillColor.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    color = (parseInt(matches[0]) << 16) | (parseInt(matches[1]) << 8) | parseInt(matches[2]);
                }
            } else {
                // Culoare aleatorie pastel
                color = Math.random() * 0xffffff;
            }

            // Cache material pentru culori similare
            const colorKey = `room_${color.toString(16)}`;
            if (!materialCache.has(colorKey)) {
                materialCache.set(colorKey, new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.7,
                    metalness: 0.1,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                }));
            }
            const material = materialCache.get(colorKey);

            const room = new THREE.Mesh(geometry, material);
            room.rotation.x = -Math.PI / 2;
            room.position.y = floorHeight;
            room.receiveShadow = true;
            room.frustumCulled = true;

            roomsGroup.add(room);
            totalRooms++;
        }

        // Creare camerƒÉ circularƒÉ
        function createCircularRoom(cx, cy, radius, fillColor) {
            const segments = Math.max(32, Math.floor(radius / 5)); // Adaptiv la dimensiune
            const shape = new THREE.Shape();

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;

                if (i === 0) {
                    shape.moveTo(x, y);
                } else {
                    shape.lineTo(x, y);
                }
                updateBounds(x, floorHeight, y);
            }
            shape.closePath();

            const extrudeSettings = {
                depth: 10,
                bevelEnabled: false,
                curveSegments: 1
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const color = parseColor(fillColor);
            const colorKey = `room_${color.toString(16)}`;

            if (!materialCache.has(colorKey)) {
                materialCache.set(colorKey, new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.7,
                    metalness: 0.1,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                }));
            }

            const room = new THREE.Mesh(geometry, materialCache.get(colorKey));
            room.rotation.x = -Math.PI / 2;
            room.position.y = floorHeight;
            room.receiveShadow = true;
            room.frustumCulled = true;

            roomsGroup.add(room);
            totalRooms++;
        }

        // Creare camerƒÉ elipticƒÉ
        function createEllipticalRoom(cx, cy, rx, ry, fillColor) {
            const segments = Math.max(32, Math.floor((rx + ry) / 10));
            const shape = new THREE.Shape();

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = cx + Math.cos(angle) * rx;
                const y = cy + Math.sin(angle) * ry;

                if (i === 0) {
                    shape.moveTo(x, y);
                } else {
                    shape.lineTo(x, y);
                }
                updateBounds(x, floorHeight, y);
            }
            shape.closePath();

            const extrudeSettings = {
                depth: 10,
                bevelEnabled: false,
                curveSegments: 1
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const color = parseColor(fillColor);
            const colorKey = `room_${color.toString(16)}`;

            if (!materialCache.has(colorKey)) {
                materialCache.set(colorKey, new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.7,
                    metalness: 0.1,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                }));
            }

            const room = new THREE.Mesh(geometry, materialCache.get(colorKey));
            room.rotation.x = -Math.PI / 2;
            room.position.y = floorHeight;
            room.receiveShadow = true;
            room.frustumCulled = true;

            roomsGroup.add(room);
            totalRooms++;
        }

        // Creare perete circular
        function createCircularWall(cx, cy, radius, thickness = 5) {
            const segments = Math.max(32, Math.floor(radius / 5));

            for (let i = 0; i < segments; i++) {
                const angle1 = (i / segments) * Math.PI * 2;
                const angle2 = ((i + 1) / segments) * Math.PI * 2;

                const x1 = cx + Math.cos(angle1) * radius;
                const y1 = cy + Math.sin(angle1) * radius;
                const x2 = cx + Math.cos(angle2) * radius;
                const y2 = cy + Math.sin(angle2) * radius;

                createWall(x1, y1, x2, y2, thickness);
            }
        }

        // Creare perete eliptic
        function createEllipticalWall(cx, cy, rx, ry, thickness = 5) {
            const segments = Math.max(32, Math.floor((rx + ry) / 10));

            for (let i = 0; i < segments; i++) {
                const angle1 = (i / segments) * Math.PI * 2;
                const angle2 = ((i + 1) / segments) * Math.PI * 2;

                const x1 = cx + Math.cos(angle1) * rx;
                const y1 = cy + Math.sin(angle1) * ry;
                const x2 = cx + Math.cos(angle2) * rx;
                const y2 = cy + Math.sin(angle2) * ry;

                createWall(x1, y1, x2, y2, thickness);
            }
        }

        // Helper pentru parsare culori
        function parseColor(fillColor) {
            let color = 0xcccccc;
            if (fillColor && fillColor.startsWith('#')) {
                color = parseInt(fillColor.substring(1), 16);
            } else if (fillColor && fillColor.startsWith('rgb')) {
                const matches = fillColor.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    color = (parseInt(matches[0]) << 16) | (parseInt(matches[1]) << 8) | parseInt(matches[2]);
                }
            } else if (fillColor) {
                color = Math.random() * 0xffffff;
            }
            return color;
        }

        // Resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Anima»õie
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Centrare camerƒÉ pe planul 3D
        function centerCameraOnPlan() {
            if (planBounds.minX === Infinity) return; // No geometry loaded

            const centerX = (planBounds.minX + planBounds.maxX) / 2;
            const centerY = (planBounds.minY + planBounds.maxY) / 2;
            const centerZ = (planBounds.minZ + planBounds.maxZ) / 2;

            const sizeX = planBounds.maxX - planBounds.minX;
            const sizeY = planBounds.maxY - planBounds.minY;
            const sizeZ = planBounds.maxZ - planBounds.minZ;
            const maxSize = Math.max(sizeX, sizeY, sizeZ);

            // CalculeazƒÉ distan»õa optimƒÉ pentru a vedea tot
            const distance = maxSize * 1.5;

            // SeteazƒÉ camera la o pozi»õie izometricƒÉ frumoasƒÉ
            camera.position.set(
                centerX + distance * 0.7,
                centerY + distance * 0.8,
                centerZ + distance * 0.7
            );

            controls.target.set(centerX, centerY, centerZ);
            camera.lookAt(centerX, centerY, centerZ);
            controls.update();

            console.log(`üìç Camera centratƒÉ pe: (${centerX.toFixed(0)}, ${centerY.toFixed(0)}, ${centerZ.toFixed(0)})`);
            console.log(`üìè Dimensiuni plan: ${sizeX.toFixed(0)} x ${sizeZ.toFixed(0)}`);
        }

        // Resetare vedere
        function resetView() {
            centerCameraOnPlan();
        }

        // Toggle √Æntre vedere 2D (de sus) »ôi 3D
        function toggle2DView() {
            is2DView = !is2DView;

            if (planBounds.minX === Infinity) return;

            const centerX = (planBounds.minX + planBounds.maxX) / 2;
            const centerY = (planBounds.minY + planBounds.maxY) / 2;
            const centerZ = (planBounds.minZ + planBounds.maxZ) / 2;

            const sizeX = planBounds.maxX - planBounds.minX;
            const sizeZ = planBounds.maxZ - planBounds.minZ;
            const maxSize = Math.max(sizeX, sizeZ);

            if (is2DView) {
                // Vedere 2D - camerƒÉ deasupra privind √Æn jos
                const height = maxSize * 1.2;
                camera.position.set(centerX, height, centerZ);
                camera.lookAt(centerX, 0, centerZ);
                controls.target.set(centerX, 0, centerZ);

                // Restric»õioneazƒÉ rota»õia √Æn 2D
                controls.maxPolarAngle = 0.1;
                controls.minPolarAngle = 0;

                document.getElementById('toggle2D').textContent = 'üîÑ Vedere 3D';
                console.log('üìê Modul 2D activat');
            } else {
                // Vedere 3D - pozi»õie izometricƒÉ
                const distance = maxSize * 1.5;
                camera.position.set(
                    centerX + distance * 0.7,
                    centerY + distance * 0.8,
                    centerZ + distance * 0.7
                );
                camera.lookAt(centerX, centerY, centerZ);
                controls.target.set(centerX, centerY, centerZ);

                // Permite rota»õie completƒÉ √Æn 3D
                controls.maxPolarAngle = Math.PI / 2;
                controls.minPolarAngle = 0;

                document.getElementById('toggle2D').textContent = 'üìê Vedere 2D';
                console.log('üéÆ Modul 3D activat');
            }

            controls.update();
        }

        // Toggle vizibilitate
        function toggleWalls() {
            showWalls = !showWalls;
            wallsGroup.visible = showWalls;
        }

        function toggleRooms() {
            showRooms = !showRooms;
            roomsGroup.visible = showRooms;
        }

        function toggleLabels() {
            showLabels = !showLabels;
            labelsGroup.visible = showLabels;
        }

        // Actualizare √ÆnƒÉl»õime pere»õi - optimizat
        function updateWallHeight(newHeight) {
            wallHeight = newHeight;

            // Clear cache pentru geometrii vechi
            geometryCache.forEach((geom, key) => {
                if (key.startsWith('wall_')) {
                    geom.dispose();
                }
            });
            geometryCache.clear();

            // RefƒÉ toatƒÉ scena pentru consisten»õƒÉ
            const tempSvg = svgData;
            clearScene();
            svgData = tempSvg;
            parseSVGAndCreate3D();

            renderer.shadowMap.needsUpdate = true;
        }

        // Clear scene helper
        function clearScene() {
            while (wallsGroup.children.length > 0) {
                const obj = wallsGroup.children[0];
                wallsGroup.remove(obj);
            }
            while (roomsGroup.children.length > 0) {
                const obj = roomsGroup.children[0];
                roomsGroup.remove(obj);
            }
            totalWalls = 0;
            totalRooms = 0;
        }

        // Actualizare √ÆnƒÉl»õime podea
        function updateFloorHeight(newHeight) {
            floorHeight = newHeight;

            roomsGroup.children.forEach(room => {
                room.position.y = floorHeight;
            });

            wallsGroup.children.forEach(wall => {
                wall.position.y = wallHeight / 2 + floorHeight;
            });
        }

        // Event listeners pentru controale
        document.getElementById('resetView').addEventListener('click', resetView);
        document.getElementById('toggleWalls').addEventListener('click', toggleWalls);
        document.getElementById('toggleRooms').addEventListener('click', toggleRooms);
        document.getElementById('toggleLabels').addEventListener('click', toggleLabels);
        document.getElementById('toggle2D').addEventListener('click', toggle2DView);

        document.getElementById('wallHeight').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('wallHeightValue').textContent = value;
            updateWallHeight(value);
        });

        document.getElementById('floorHeight').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('floorHeightValue').textContent = value;
            updateFloorHeight(value);
        });

        // Ini»õializare
        initScene();
        loadSVG();
    </script>
</body>

</html>